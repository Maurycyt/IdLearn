        -:    0:Source:/home/maurycyt/Documents/IO/idlearn/defaultProblemPackages/test/packageUtils.h
        -:    0:Graph:/home/maurycyt/Documents/IO/idlearn/defaultProblemPackages/test/cmake-build-debug-coverage/CMakeFiles/packageUtilsTest.dir/packageUtilsTest.cpp.gcno
        -:    0:Data:/home/maurycyt/Documents/IO/idlearn/defaultProblemPackages/test/cmake-build-debug-coverage/CMakeFiles/packageUtilsTest.dir/packageUtilsTest.cpp.gcda
        -:    0:Runs:1
        -:    1:#pragma once
        -:    2:
        -:    3:#include <cstdint>
        -:    4:#include <cfloat>
        -:    5:#include <random>
        -:    6:#include <fstream>
        -:    7:#include <cerrno>
        -:    8:#include <stdexcept>
        -:    9:
        -:   10:namespace pUtils {
        -:   11:
        -:   12:using si = int32_t;
        -:   13:using ui = uint32_t;
        -:   14:using sll = int64_t;
        -:   15:using ull = uint64_t;
        -:   16:using dbl = double;
        -:   17:using ldbl = long double;
        -:   18:
        -:   19:const si SI_MIN = -2147483648;
        -:   20:const si SI_MAX = 2147483647;
        -:   21:const ui UI_MIN = 0;
        -:   22:const ui UI_MAX = 4294967295;
        -:   23:const sll SLL_MIN = -9223372036854775808ULL;
        -:   24:const sll SLL_MAX = 9223372036854775807ULL;
        -:   25:const ull ULL_MIN = 0;
        -:   26:const ull ULL_MAX = 18446744073709551615ULL;
        -:   27:// Floating-point limits defined in <cfloat>.
        -:   28:
        -:   29:template<typename T>
        -:   30:concept integral = std::same_as<T, ull> || std::same_as<T, sll> || std::same_as<T, ui> || std::same_as<T, si>;
        -:   31:
        -:   32:template<typename T>
        -:   33:concept signedIntegral = std::same_as<T, sll> || std::same_as<T, si>;
        -:   34:
        -:   35:template<typename T>
        -:   36:concept unsignedIntegral = std::same_as<T, ull> || std::same_as<T, ui>;
        -:   37:
        -:   38:template<typename T>
        -:   39:concept mediumIntegral = std::same_as<T, ui> || std::same_as<T, si>;
        -:   40:
        -:   41:template<typename T>
        -:   42:concept longIntegral = std::same_as<T, ull> || std::same_as<T, sll>;
        -:   43:
        -:   44:template<typename T>
        -:   45:concept floatingPoint = std::same_as<T, ldbl> || std::same_as<T, dbl>;
        -:   46:
        -:   47:template<typename T>
        -:   48:concept packageType = integral<T> || floatingPoint<T>;
        -:   49:
        -:   50:/**
        -:   51: * Returns the maximum value of an integral type.
        -:   52: * @tparam T The integral type.
        -:   53: * @return The type's maximum value.
        -:   54: */
        -:   55:template<integral T>
        -:   56:ull integralMaximum() {
        -:   57:	if constexpr (std::same_as<T, ull>) {
        -:   58:		return ULL_MAX;
        -:   59:	} else if constexpr (std::same_as<T, sll>) {
        -:   60:		return SLL_MAX;
        -:   61:	} else if constexpr (std::same_as<T, ui>) {
        -:   62:		return UI_MAX;
        -:   63:	} else {
        -:   64:		return SI_MAX;
        -:   65:	}
        -:   66:}
        -:   67:
        -:   68:/**
        -:   69: * Returns the minimum value of an integral type.
        -:   70: * @tparam T The integral type.
        -:   71: * @return The type's minimum value.
        -:   72: */
        -:   73:template<integral T>
        -:   74:sll integralMinimum() {
        -:   75:	if constexpr (std::same_as<T, ull>) {
        -:   76:		return ULL_MIN;
        -:   77:	} else if constexpr (std::same_as<T, sll>) {
        -:   78:		return SLL_MIN;
        -:   79:	} else if constexpr (std::same_as<T, ui>) {
        -:   80:		return UI_MIN;
        -:   81:	} else {
        -:   82:		return SI_MIN;
        -:   83:	}
        -:   84:}
        -:   85:
        -:   86:/**
        -:   87: * Returns the negated minimum value of an integral type.
        -:   88: * @tparam T The integral type.
        -:   89: * @return The type's negated minimum value.
        -:   90: */
        -:   91:template<integral T>
        -:   92:ull integralNegatedMinimum() {
        -:   93:	if constexpr (std::same_as<T, ull>) {
        -:   94:		return ULL_MIN;
        -:   95:	} else if constexpr (std::same_as<T, sll>) {
        -:   96:		return ull(SLL_MAX) + 1;
        -:   97:	} else if constexpr (std::same_as<T, ui>) {
        -:   98:		return UI_MIN;
        -:   99:	} else {
        -:  100:		return ull(SI_MAX) + 1;
        -:  101:	}
        -:  102:}
        -:  103:
        -:  104:template<floatingPoint T>
        -:  105:ldbl floatingPointMinimum() {
        -:  106:	if constexpr (std::same_as<T, ldbl>) {
        -:  107:		return LDBL_MIN;
        -:  108:	} else {
        -:  109:		return DBL_MIN;
        -:  110:	}
        -:  111:}
        -:  112:
        -:  113:template<floatingPoint T>
        -:  114:ldbl floatingPointMaximum() {
        -:  115:	if constexpr (std::same_as<T, ldbl>) {
        -:  116:		return LDBL_MAX;
        -:  117:	} else {
        -:  118:		return DBL_MAX;
        -:  119:	}
        -:  120:}
        -:  121:
        -:  122:template<packageType T>
        -:  123:T minimumValue() {
        -:  124:	if constexpr (integral<T>) {
        -:  125:		return integralMinimum<T>();
        -:  126:	} else {
        -:  127:		return floatingPointMinimum<T>();
        -:  128:	}
        -:  129:}
        -:  130:
        -:  131:template<packageType T>
        -:  132:T maximumValue() {
        -:  133:	if constexpr (integral<T>) {
        -:  134:		return integralMaximum<T>();
        -:  135:	} else {
        -:  136:		return floatingPointMaximum<T>();
        -:  137:	}
        -:  138:}
        -:  139:
        -:  140:class Random {
        -:  141:private:
        -:  142:	// Mersenne Twister random number generator, generates numbers in range [0, 2^64).
        -:  143:	static std::mt19937_64 rng;
        -:  144:
        -:  145:public:
        -:  146:	Random() = delete;
        -:  147:
        -:  148:	Random(Random &r) = delete;
        -:  149:
        -:  150:	template<packageType T>
  6000000:  151:	static T rand() {
        -:  152:		if constexpr (integral<T>) {
        -:  153:			// Random integer in the range of the returned type.
  4000000:  154:			return rng();
  1000000:  154-block  0
call    0 returned 1000000
branch  1 taken 500243 (fallthrough)
branch  2 taken 499757
  1000000:  154-block  1
call    3 returned 1000000
  1000000:  154-block  2
call    4 returned 1000000
branch  5 taken 500011 (fallthrough)
branch  6 taken 499989
  1000000:  154-block  3
call    7 returned 1000000
        -:  155:		} else {
        -:  156:			// Random real number in the range [0, 1).
  2000000:  157:			ldbl result = rng();
  1000000:  157-block  0
call    0 returned 1000000
  1000000:  157-block  1
call    1 returned 1000000
  2000000:  158:			result /= (1LL << 32);
  2000000:  159:			return result / (1LL << 32);
        -:  160:		}
        -:  161:	}
        -:  162:};
        -:  163:
        -:  164:// Initialize the private static member, lest there will be a linker error.
        -:  165:std::mt19937_64 Random::rng;
        -:  166:
        6:  167:class EOFException : std::exception {
        -:  168:public:
function _ZNK6pUtils12EOFException4whatEv called 0 returned 0% blocks executed 0%
    #####:  169:	const char * what() const noexcept override {
    #####:  170:		return "File reached EOF and tried to be readToBuffer from.";
        -:  171:	}
        -:  172:};
        -:  173:
       26:  174:class ParsingException : std::exception {
        -:  175:public:
function _ZNK6pUtils16ParsingException4whatEv called 0 returned 0% blocks executed 0%
    #####:  176:	const char * what() const noexcept override {
    #####:  177:		return "Cannot convert string to expected type.";
        -:  178:	}
        -:  179:};
        -:  180:
       30:  181:class OverflowException : std::exception {
        -:  182:public:
function _ZNK6pUtils17OverflowException4whatEv called 0 returned 0% blocks executed 0%
    #####:  183:		const char * what() const noexcept override {
    #####:  184:			return "Value represented by string is not in range of type.";
        -:  185:		}
        -:  186:};
        -:  187:
        -:  188:class OutOfRangeException : std::exception {
        -:  189:public:
        -:  190:		const char * what() const noexcept override {
        -:  191:			return "Parsed value is not in expected range.";
        -:  192:		}
        -:  193:};
        -:  194:
        -:  195:class Reader {
        -:  196:private:
        -:  197:	std::ifstream file;
        -:  198:	std::string buffer;
        -:  199:
function _ZN6pUtils6Reader14skipWhitespaceEv called 252 returned 100% blocks executed 100%
      252:  200:	void skipWhitespace() {
     2520:  201:		while (!file.eof() && std::isspace(file.peek())) {
      252:  201-block  0
     2520:  201-block  1
branch  0 taken 2514 (fallthrough)
branch  1 taken 6
     2514:  201-block  2
call    2 returned 2514
branch  3 taken 2268 (fallthrough)
branch  4 taken 246
     2268:  202:			file.get();
     2268:  202-block  0
call    0 returned 2268
        -:  203:		}
      252:  204:	}
        -:  205:
function _ZN6pUtils6Reader12readToBufferEv called 126 returned 95% blocks executed 100%
      126:  206:	void readToBuffer() {
      126:  207:		skipWhitespace();
      126:  207-block  0
call    0 returned 126
      126:  208:		if (file.eof()) {
branch  0 taken 6 (fallthrough)
branch  1 taken 120
        6:  209:			throw EOFException();
        6:  209-block  0
call    0 returned 6
call    1 returned 0
        -:  210:		}
      120:  211:		file >> buffer;
      120:  211-block  0
call    0 returned 120
      120:  212:	}
        -:  213:
     1136:  214:	static bool isDigit(char c) {
     1136:  215:		return (c >= '0' && c <= '9');
        -:  216:	}
        -:  217:
        -:  218:	// Possible optimization: array with values of ULL_MAX - digit / 10 for all digit values.
        -:  219:	/**
        -:  220:	 * Parses the string under the given pointer into an unsigned long long.
        -:  221:	 * Sets errno to 0 on success.
        -:  222:	 * Sets errno to 1 on unexpected character or lack of characters (parsing error).
        -:  223:	 * Sets errno to 2 on overflow.
        -:  224:	 * @param str Pointer to the string to be parsed.
        -:  225:	 * @param len Length of the string to be parsed.
        -:  226:	 * @return The parsed value, always 0 on failure.
        -:  227:	 */
function _ZN6pUtils6Reader8parseULLEPKcm called 80 returned 100% blocks executed 100%
       80:  228:	static ull parseULL(const char * str, const size_t len) {
       80:  229:		errno = 0;
       80:  230:		if (len == 0) {
       80:  230-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 76
        4:  231:			errno = 1;
        4:  232:			return 0;
        4:  232-block  0
        -:  233:		}
        -:  234:
        -:  235:		ull result = 0;
        -:  236:
      812:  237:		for (size_t index = 0; index < len; index++) {
      812:  237-block  0
branch  0 taken 756
branch  1 taken 56 (fallthrough)
      756:  238:			if (!isDigit(str[index])) {
      756:  238-block  0
branch  0 taken 16 (fallthrough)
branch  1 taken 740
       16:  239:				errno = 1;
       16:  240:				return 0;
       16:  240-block  0
        -:  241:			}
      740:  242:			int digit = str[index] - '0';
        -:  243:			// check that result * 10 + digit <= ULL_MAX
      740:  244:			if ((ULL_MAX - digit) / 10 < result) {
      740:  244-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 736
        4:  245:				errno = 2;
        4:  246:				return 0;
        4:  246-block  0
        -:  247:			}
      736:  248:			result = result * 10 + digit;
      736:  248-block  0
        -:  249:		}
        -:  250:
        -:  251:		return result;
        -:  252:	}
        -:  253:
        -:  254:	/**
        -:  255:	 * Parses the string under the given pointer into a long double.
        -:  256:	 * Sets errno to 0 on success.
        -:  257:	 * Sets errno to 1 on unexpected character or lack of characters (parsing error).
        -:  258:	 * @param str Pointer to the string to be parsed.
        -:  259:	 * @param len Length of the string to be parsed.
        -:  260:	 * @return The parsed value, always 0 on failure.
        -:  261:	 */
function _ZN6pUtils6Reader9parseLDBLEPKcm called 40 returned 100% blocks executed 100%
       40:  262:	static ldbl parseLDBL(const char * str, const size_t len) {
       40:  263:		errno = 0;
       40:  264:		if (len == 0) {
       40:  264-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 38
        2:  265:			errno = 1;
        2:  266:			return 0;
        2:  266-block  0
        -:  267:		}
        -:  268:
        -:  269:		ldbl result = 0;
      408:  270:		ldbl fraction = 0.1;
        -:  271:
        -:  272:		size_t index = 0;
      408:  273:		for (; index < len; index++) {
      408:  273-block  0
branch  0 taken 378
branch  1 taken 30
      378:  274:			if (str[index] == '.') {
      378:  274-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 372
        6:  275:				index++;
        6:  276:				break;
        6:  276-block  0
        -:  277:			}
      372:  278:			if (!isDigit(str[index])) {
      372:  278-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 370
        2:  279:				errno = 1;
        2:  280:				return 0;
        2:  280-block  0
        -:  281:			}
      370:  282:			int digit = str[index] - '0';
      370:  283:			result = result * 10 + digit;
      370:  283-block  0
        -:  284:		}
        -:  285:
       42:  286:		for(; index < len; index++) {
       42:  286-block  0
branch  0 taken 8
branch  1 taken 34 (fallthrough)
        8:  287:			if (!isDigit(str[index])) {
        8:  287-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 6
        2:  288:				errno = 1;
        2:  289:				return 0;
        2:  289-block  0
        -:  290:			}
        6:  291:			int digit = str[index] - '0';
        6:  292:			result = result + digit * fraction;
        6:  293:			fraction /= 10;
        6:  293-block  0
        -:  294:		}
        -:  295:
        -:  296:		return result;
        -:  297:	}
        -:  298:
        -:  299:
        -:  300:public:
        6:  301:	Reader(std::string filename) : file(filename) {
        1:  301-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  301-block  1
branch  3 taken 0 (fallthrough)
branch  4 taken 1
        1:  301-block  2
call    5 returned 1
branch  6 taken 1 (fallthrough)
branch  7 taken 0 (throw)
        1:  301-block  3
branch  8 taken 0 (fallthrough)
branch  9 taken 1
        1:  301-block  4
call   10 returned 1
branch 11 taken 1 (fallthrough)
branch 12 taken 0 (throw)
        1:  301-block  5
branch 13 taken 0 (fallthrough)
branch 14 taken 1
        1:  301-block  6
call   15 returned 1
branch 16 taken 1 (fallthrough)
branch 17 taken 0 (throw)
        1:  301-block  7
branch 18 taken 0 (fallthrough)
branch 19 taken 1
        1:  301-block  8
call   20 returned 1
branch 21 taken 1 (fallthrough)
branch 22 taken 0 (throw)
        1:  301-block  9
branch 23 taken 0 (fallthrough)
branch 24 taken 1
        1:  301-block 10
call   25 returned 1
branch 26 taken 1 (fallthrough)
branch 27 taken 0 (throw)
        1:  301-block 11
branch 28 taken 0 (fallthrough)
branch 29 taken 1
        -:  302:	}
        -:  303:
      126:  304:	bool eof() {
      126:  305:		skipWhitespace();
       20:  305-block  0
call    0 returned 20
branch  1 taken 20 (fallthrough)
branch  2 taken 0 (throw)
        1:  305-block  1
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
       20:  305-block  2
call    6 returned 20
branch  7 taken 20 (fallthrough)
branch  8 taken 0 (throw)
        1:  305-block  3
call    9 returned 1
branch 10 taken 1 (fallthrough)
branch 11 taken 0 (throw)
       20:  305-block  4
call   12 returned 20
branch 13 taken 20 (fallthrough)
branch 14 taken 0 (throw)
        1:  305-block  5
call   15 returned 1
branch 16 taken 1 (fallthrough)
branch 17 taken 0 (throw)
       20:  305-block  6
call   18 returned 20
branch 19 taken 20 (fallthrough)
branch 20 taken 0 (throw)
        1:  305-block  7
call   21 returned 1
branch 22 taken 1 (fallthrough)
branch 23 taken 0 (throw)
       20:  305-block  8
call   24 returned 20
branch 25 taken 20 (fallthrough)
branch 26 taken 0 (throw)
        1:  305-block  9
call   27 returned 1
branch 28 taken 1 (fallthrough)
branch 29 taken 0 (throw)
       20:  305-block 10
call   30 returned 20
branch 31 taken 20 (fallthrough)
branch 32 taken 0 (throw)
        1:  305-block 11
call   33 returned 1
branch 34 taken 1 (fallthrough)
branch 35 taken 0 (throw)
      126:  306:		return file.eof();
       20:  306-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 20
        1:  306-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
       20:  306-block  2
branch  4 taken 0 (fallthrough)
branch  5 taken 20
        1:  306-block  3
branch  6 taken 0 (fallthrough)
branch  7 taken 1
       20:  306-block  4
branch  8 taken 0 (fallthrough)
branch  9 taken 20
        1:  306-block  5
branch 10 taken 0 (fallthrough)
branch 11 taken 1
       20:  306-block  6
branch 12 taken 0 (fallthrough)
branch 13 taken 20
        1:  306-block  7
branch 14 taken 0 (fallthrough)
branch 15 taken 1
       20:  306-block  8
branch 16 taken 0 (fallthrough)
branch 17 taken 20
        1:  306-block  9
branch 18 taken 0 (fallthrough)
branch 19 taken 1
       20:  306-block 10
branch 20 taken 0 (fallthrough)
branch 21 taken 20
        1:  306-block 11
branch 22 taken 0 (fallthrough)
branch 23 taken 1
        -:  307:	}
        -:  308:
        -:  309:	template<integral T>
       84:  310:	T read() {
       84:  311:		readToBuffer();
        -:  312:
        -:  313:		if constexpr (signedIntegral<T>) {
        -:  314:			// reading a signed integer
       40:  315:			if (buffer[0] == '-') {
        -:  316:				// negative integer
       14:  317:				ull result = parseULL(buffer.data() + 1, buffer.size() - 1);
       14:  318:				ull negatedMinimum = integralNegatedMinimum<T>();
       14:  319:				if (result > negatedMinimum) {
        4:  320:					errno = 2;
        -:  321:				}
       14:  322:				if (errno == 1) {
        4:  323:					throw ParsingException();
       10:  324:				} else if (errno == 2) {
        4:  325:					throw OverflowException();
        -:  326:				}
        6:  327:				if (result == negatedMinimum) {
        -:  328:					return integralMinimum<T>();
        -:  329:				}
        4:  330:				return -T(result);
        -:  331:			} else {
        -:  332:				// positive integer
       26:  333:				ull result = parseULL(buffer.data(), buffer.size());
       26:  334:				if (result > integralMaximum<T>()) {
        8:  335:					errno = 2;
        -:  336:				}
       26:  337:				if (errno == 1) {
        6:  338:					throw ParsingException();
       20:  339:				} else if (errno == 2) {
       10:  340:					throw OverflowException();
        -:  341:				}
        3:  342:				return result;
        -:  343:			}
        -:  344:		} else {
        -:  345:			// reading an unsigned integral
        -:  346:			ull result;
       40:  347:			if (buffer[0] == '-') {
        -:  348:				// we expect an unsigned integer, but we check for parsing errors before we check overflow.
       14:  349:				result = parseULL(buffer.data() + 1, buffer.size() - 1);
       14:  350:				if (errno == 0) {
       10:  351:					errno = 2;
        -:  352:				}
        -:  353:			} else {
       26:  354:				result = parseULL(buffer.data(), buffer.size());
        -:  355:			}
       20:  356:			if (result > integralMaximum<T>()) {
        6:  357:				errno = 2;
        -:  358:			}
       40:  359:			if (errno == 1) {
       10:  360:				throw ParsingException();
       30:  361:			} else if (errno == 2) {
       16:  362:				throw OverflowException();
        -:  363:			}
       14:  364:			return result;
        -:  365:		}
        -:  366:	}
------------------
_ZN6pUtils6Reader4readIiEET_v:
function _ZN6pUtils6Reader4readIiEET_v called 21 returned 24% blocks executed 100%
       21:  310:	T read() {
       21:  311:		readToBuffer();
       21:  311-block  0
call    0 returned 20
        -:  312:
        -:  313:		if constexpr (signedIntegral<T>) {
        -:  314:			// reading a signed integer
       20:  315:			if (buffer[0] == '-') {
branch  0 taken 7 (fallthrough)
branch  1 taken 13
        -:  316:				// negative integer
        7:  317:				ull result = parseULL(buffer.data() + 1, buffer.size() - 1);
        7:  317-block  0
call    0 returned 7
        7:  318:				ull negatedMinimum = integralNegatedMinimum<T>();
        7:  319:				if (result > negatedMinimum) {
branch  0 taken 3 (fallthrough)
branch  1 taken 4
        3:  320:					errno = 2;
        3:  320-block  0
        -:  321:				}
        7:  322:				if (errno == 1) {
        7:  322-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 5
        2:  323:					throw ParsingException();
        2:  323-block  0
call    0 returned 2
call    1 returned 0
        5:  324:				} else if (errno == 2) {
        5:  324-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 2
        3:  325:					throw OverflowException();
        3:  325-block  0
call    0 returned 3
call    1 returned 0
        -:  326:				}
        2:  327:				if (result == negatedMinimum) {
        2:  327-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -:  328:					return integralMinimum<T>();
        -:  329:				}
        1:  330:				return -T(result);
        1:  330-block  0
        -:  331:			} else {
        -:  332:				// positive integer
       13:  333:				ull result = parseULL(buffer.data(), buffer.size());
       13:  333-block  0
call    0 returned 13
       13:  334:				if (result > integralMaximum<T>()) {
branch  0 taken 6 (fallthrough)
branch  1 taken 7
        6:  335:					errno = 2;
        6:  335-block  0
        -:  336:				}
       13:  337:				if (errno == 1) {
       13:  337-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 10
        3:  338:					throw ParsingException();
        3:  338-block  0
call    0 returned 3
call    1 returned 0
       10:  339:				} else if (errno == 2) {
       10:  339-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 3
        7:  340:					throw OverflowException();
        7:  340-block  0
call    0 returned 7
call    1 returned 0
        -:  341:				}
        3:  342:				return result;
        3:  342-block  0
        -:  343:			}
        -:  344:		} else {
        -:  345:			// reading an unsigned integral
        -:  346:			ull result;
        -:  347:			if (buffer[0] == '-') {
        -:  348:				// we expect an unsigned integer, but we check for parsing errors before we check overflow.
        -:  349:				result = parseULL(buffer.data() + 1, buffer.size() - 1);
        -:  350:				if (errno == 0) {
        -:  351:					errno = 2;
        -:  352:				}
        -:  353:			} else {
        -:  354:				result = parseULL(buffer.data(), buffer.size());
        -:  355:			}
        -:  356:			if (result > integralMaximum<T>()) {
        -:  357:				errno = 2;
        -:  358:			}
        -:  359:			if (errno == 1) {
        -:  360:				throw ParsingException();
        -:  361:			} else if (errno == 2) {
        -:  362:				throw OverflowException();
        -:  363:			}
        -:  364:			return result;
        -:  365:		}
        -:  366:	}
------------------
_ZN6pUtils6Reader4readIjEET_v:
function _ZN6pUtils6Reader4readIjEET_v called 21 returned 24% blocks executed 100%
       21:  310:	T read() {
       21:  311:		readToBuffer();
       21:  311-block  0
call    0 returned 20
        -:  312:
        -:  313:		if constexpr (signedIntegral<T>) {
        -:  314:			// reading a signed integer
        -:  315:			if (buffer[0] == '-') {
        -:  316:				// negative integer
        -:  317:				ull result = parseULL(buffer.data() + 1, buffer.size() - 1);
        -:  318:				ull negatedMinimum = integralNegatedMinimum<T>();
        -:  319:				if (result > negatedMinimum) {
        -:  320:					errno = 2;
        -:  321:				}
        -:  322:				if (errno == 1) {
        -:  323:					throw ParsingException();
        -:  324:				} else if (errno == 2) {
        -:  325:					throw OverflowException();
        -:  326:				}
        -:  327:				if (result == negatedMinimum) {
        -:  328:					return integralMinimum<T>();
        -:  329:				}
        -:  330:				return -T(result);
        -:  331:			} else {
        -:  332:				// positive integer
        -:  333:				ull result = parseULL(buffer.data(), buffer.size());
        -:  334:				if (result > integralMaximum<T>()) {
        -:  335:					errno = 2;
        -:  336:				}
        -:  337:				if (errno == 1) {
        -:  338:					throw ParsingException();
        -:  339:				} else if (errno == 2) {
        -:  340:					throw OverflowException();
        -:  341:				}
        -:  342:				return result;
        -:  343:			}
        -:  344:		} else {
        -:  345:			// reading an unsigned integral
        -:  346:			ull result;
       20:  347:			if (buffer[0] == '-') {
branch  0 taken 7 (fallthrough)
branch  1 taken 13
        -:  348:				// we expect an unsigned integer, but we check for parsing errors before we check overflow.
        7:  349:				result = parseULL(buffer.data() + 1, buffer.size() - 1);
        7:  349-block  0
call    0 returned 7
        7:  350:				if (errno == 0) {
branch  0 taken 5 (fallthrough)
branch  1 taken 2
        5:  351:					errno = 2;
        5:  351-block  0
        -:  352:				}
        -:  353:			} else {
       13:  354:				result = parseULL(buffer.data(), buffer.size());
       13:  354-block  0
call    0 returned 13
        -:  355:			}
       20:  356:			if (result > integralMaximum<T>()) {
       20:  356-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 14
        6:  357:				errno = 2;
        6:  357-block  0
        -:  358:			}
       20:  359:			if (errno == 1) {
       20:  359-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 15
        5:  360:				throw ParsingException();
        5:  360-block  0
call    0 returned 5
call    1 returned 0
       15:  361:			} else if (errno == 2) {
       15:  361-block  0
branch  0 taken 10 (fallthrough)
branch  1 taken 5
       10:  362:				throw OverflowException();
       10:  362-block  0
call    0 returned 10
call    1 returned 0
        -:  363:			}
        5:  364:			return result;
        -:  365:		}
        -:  366:	}
------------------
_ZN6pUtils6Reader4readIlEET_v:
function _ZN6pUtils6Reader4readIlEET_v called 21 returned 52% blocks executed 100%
       21:  310:	T read() {
       21:  311:		readToBuffer();
       21:  311-block  0
call    0 returned 20
        -:  312:
        -:  313:		if constexpr (signedIntegral<T>) {
        -:  314:			// reading a signed integer
       20:  315:			if (buffer[0] == '-') {
branch  0 taken 7 (fallthrough)
branch  1 taken 13
        -:  316:				// negative integer
        7:  317:				ull result = parseULL(buffer.data() + 1, buffer.size() - 1);
        7:  317-block  0
call    0 returned 7
        7:  318:				ull negatedMinimum = integralNegatedMinimum<T>();
        7:  319:				if (result > negatedMinimum) {
branch  0 taken 1 (fallthrough)
branch  1 taken 6
        1:  320:					errno = 2;
        1:  320-block  0
        -:  321:				}
        7:  322:				if (errno == 1) {
        7:  322-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 5
        2:  323:					throw ParsingException();
        2:  323-block  0
call    0 returned 2
call    1 returned 0
        5:  324:				} else if (errno == 2) {
        5:  324-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        1:  325:					throw OverflowException();
        1:  325-block  0
call    0 returned 1
call    1 returned 0
        -:  326:				}
        4:  327:				if (result == negatedMinimum) {
        4:  327-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        -:  328:					return integralMinimum<T>();
        -:  329:				}
        3:  330:				return -T(result);
        3:  330-block  0
        -:  331:			} else {
        -:  332:				// positive integer
       13:  333:				ull result = parseULL(buffer.data(), buffer.size());
       13:  333-block  0
call    0 returned 13
       13:  334:				if (result > integralMaximum<T>()) {
branch  0 taken 2 (fallthrough)
branch  1 taken 11
        2:  335:					errno = 2;
        2:  335-block  0
        -:  336:				}
       13:  337:				if (errno == 1) {
       13:  337-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 10
        3:  338:					throw ParsingException();
        3:  338-block  0
call    0 returned 3
call    1 returned 0
       10:  339:				} else if (errno == 2) {
       10:  339-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 7
        3:  340:					throw OverflowException();
        3:  340-block  0
call    0 returned 3
call    1 returned 0
        -:  341:				}
        -:  342:				return result;
        -:  343:			}
        -:  344:		} else {
        -:  345:			// reading an unsigned integral
        -:  346:			ull result;
        -:  347:			if (buffer[0] == '-') {
        -:  348:				// we expect an unsigned integer, but we check for parsing errors before we check overflow.
        -:  349:				result = parseULL(buffer.data() + 1, buffer.size() - 1);
        -:  350:				if (errno == 0) {
        -:  351:					errno = 2;
        -:  352:				}
        -:  353:			} else {
        -:  354:				result = parseULL(buffer.data(), buffer.size());
        -:  355:			}
        -:  356:			if (result > integralMaximum<T>()) {
        -:  357:				errno = 2;
        -:  358:			}
        -:  359:			if (errno == 1) {
        -:  360:				throw ParsingException();
        -:  361:			} else if (errno == 2) {
        -:  362:				throw OverflowException();
        -:  363:			}
        -:  364:			return result;
        -:  365:		}
        -:  366:	}
------------------
_ZN6pUtils6Reader4readImEET_v:
function _ZN6pUtils6Reader4readImEET_v called 21 returned 43% blocks executed 100%
       21:  310:	T read() {
       21:  311:		readToBuffer();
       21:  311-block  0
call    0 returned 20
        -:  312:
        -:  313:		if constexpr (signedIntegral<T>) {
        -:  314:			// reading a signed integer
        -:  315:			if (buffer[0] == '-') {
        -:  316:				// negative integer
        -:  317:				ull result = parseULL(buffer.data() + 1, buffer.size() - 1);
        -:  318:				ull negatedMinimum = integralNegatedMinimum<T>();
        -:  319:				if (result > negatedMinimum) {
        -:  320:					errno = 2;
        -:  321:				}
        -:  322:				if (errno == 1) {
        -:  323:					throw ParsingException();
        -:  324:				} else if (errno == 2) {
        -:  325:					throw OverflowException();
        -:  326:				}
        -:  327:				if (result == negatedMinimum) {
        -:  328:					return integralMinimum<T>();
        -:  329:				}
        -:  330:				return -T(result);
        -:  331:			} else {
        -:  332:				// positive integer
        -:  333:				ull result = parseULL(buffer.data(), buffer.size());
        -:  334:				if (result > integralMaximum<T>()) {
        -:  335:					errno = 2;
        -:  336:				}
        -:  337:				if (errno == 1) {
        -:  338:					throw ParsingException();
        -:  339:				} else if (errno == 2) {
        -:  340:					throw OverflowException();
        -:  341:				}
        -:  342:				return result;
        -:  343:			}
        -:  344:		} else {
        -:  345:			// reading an unsigned integral
        -:  346:			ull result;
       20:  347:			if (buffer[0] == '-') {
branch  0 taken 7 (fallthrough)
branch  1 taken 13
        -:  348:				// we expect an unsigned integer, but we check for parsing errors before we check overflow.
        7:  349:				result = parseULL(buffer.data() + 1, buffer.size() - 1);
        7:  349-block  0
call    0 returned 7
        7:  350:				if (errno == 0) {
branch  0 taken 5 (fallthrough)
branch  1 taken 2
        5:  351:					errno = 2;
        5:  351-block  0
        -:  352:				}
        -:  353:			} else {
       13:  354:				result = parseULL(buffer.data(), buffer.size());
       13:  354-block  0
call    0 returned 13
        -:  355:			}
        -:  356:			if (result > integralMaximum<T>()) {
        -:  357:				errno = 2;
        -:  358:			}
       20:  359:			if (errno == 1) {
       20:  359-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 15
        5:  360:				throw ParsingException();
        5:  360-block  0
call    0 returned 5
call    1 returned 0
       15:  361:			} else if (errno == 2) {
       15:  361-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 9
        6:  362:				throw OverflowException();
        6:  362-block  0
call    0 returned 6
call    1 returned 0
        -:  363:			}
        9:  364:			return result;
        -:  365:		}
        -:  366:	}
------------------
        -:  367:
        -:  368:	template<floatingPoint T>
       42:  369:	T read() {
       42:  370:		readToBuffer();
       40:  371:		bool sign = (buffer[0] == '-');
        -:  372:		T result;
       40:  373:		if (sign) {
       14:  374:			result = parseLDBL(buffer.data() + 1, buffer.size() - 1);
        -:  375:		} else {
       26:  376:			result = parseLDBL(buffer.data(), buffer.size());
        -:  377:		}
       40:  378:		if (errno == 1) {
        6:  379:			throw ParsingException();
        -:  380:		}
       34:  381:		if (sign) {
       12:  382:			return -result;
        -:  383:		} else {
        -:  384:			return result;
        -:  385:		}
        -:  386:	}
        -:  387:};
        -:  388:
        -:  389:} // namespace pUtils
